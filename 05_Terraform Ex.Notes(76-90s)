76. Terraform Output 
-------------------
terraform has the Output vaiable {}

* You can run the terraform plan again to see the old output 
* can inspect the tf.state file and see the output blocks 
Run: terraform output <output-valuable> 

This would pull updates from the output which could be an input for a script for a new file.


77. Specific versions to run the code 
--------------------------------------
Can be added to terraform{} 
-- Backend Configuration
-- Experimental features
-- Required Provider and versions 
-- Required Terraform version 
-- Pass meta data 

Terraform blocks are used for code blocks that runs on specific versions. 
Declates the latest versions of the TF plugins. 

terraform{
required_version = "1.08" 

required_providers {
  aws = {
      version = 5.7
      source = "harshicorp/aws"
  }
}
}

When we run "terraform plan" would fail, as its expecting the exact version of the terraform. Adding required_providers block can be used to declare the provider 
details and the versions. 

78. Resource TARGETTING in Terraform
-----------------------------------------
Allow the changes to a specific subset of resources rather than applying changes to the entire infrastructure. 
Use the -target ðŸš©  "<resource-name>  with terraform apply / plan command. 

terraform plan -target <>
terraform destroy -target <>
terraform init -target <>

79. DEALING with large infrastructure, when the state file is in sync
------------------------------------------------------------------------
API throttling: When we exceed the quota of number of allowed API calls. 
Single terraform plan create an enormous amount of API calls. It could impact the performance of the production instances. 

--refresh the resources while running plan 
--convert a big project to a smaller project. ec2, iam, vpc, subnet, storage, load balancers, nfs, port, policies, vnet, security group, 
-- Disable the refesh flag ðŸš©: refresh = false 


80. ZIPMAP function: 
zipmap (keylist, valuelist) 

>zipmap (["a", "b"], [1, 2]) 
{
"a" =1,
"b" =2,
}

Note: This can be used to assign values to IAM users, polcies, ports, IPs or serveral other assignment types of operations. 

81. Adding comments
:
# Single line comments 
// alternative to #
/* muti line comments */

82. Meta arguments and resource behaviour : 
Allows to customize the resouces, which comes inside the resource blocks. 

example: 
ignore_changes= [tags] 
depends_on = 
count = 
for_each = 
lifecycle {
  create_before_destroy 
  prevent_destroy (bool)
  ignore_changes (list of attribute names) 
  replace_triggered_by (list of resource or attribute references)
  }
provider = 

* You can add precondition and postcondition blocks 

83 - Lifecycle meta arguments
84 - Create_before_destroy 
  : adding conditions for a resouce dependency, ex, installing the right patches before installing apache etc etc. This prevents the downtime. 
85 - prevent_destroy 
  : safety against accidental deletes. This does not prevent the remote objects from being destroyed if the resource block is entirely removed from the config file. 
86 - Ignore_changes
  : terraform apply auto-approve 
resource "aws_instance" "example" {
  # ...

  lifecycle {
    ignore_changes = [
      # Ignore changes to tags, e.g. because a management agent
      # updates these based on some ruleset managed elsewhere.
      tags, <details>
    ]
  }
}

ignore_changes = all 

87 - Count
  : 
resource "aws_instance" "server" {
  count = 4 # create four similar EC2 instances

  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"

  tags = {
    Name = "Server ${count.index}"
  }
}

When to each for_each?  
-----------------------------
If your instances are almost identical, count is appropriate. If some of their arguments need distinct values that can't be directly derived from an integer, it's
safer to use for_each.

variable "subnet_ids" {
  type = list(string)
}

resource "aws_instance" "server" {
  # Create one instance for each subnet
  count = length(var.subnet_ids)

  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"
  subnet_id     = var.subnet_ids[count.index]

  tags = {
    Name = "Server ${count.index}"
  }
}

87 - depends_on Meta-Argument
------------------------------
Use the depends_on meta-argument to handle hidden resource or module dependencies that Terraform cannot automatically infer.
EXAMPLE CODE BLOCK: 

resource "aws_iam_role" "example" {
  name = "example"

  /* assume_role_policy is omitted for brevity in this example. Refer to the documentation for aws_iam_role for a complete example. */ 
  assume_role_policy = "..."
}

resource "aws_iam_instance_profile" "example" {
  # Because this expression refers to the role, Terraform can infer automatically that the role must be created first.
  role = aws_iam_role.example.name
}

resource "aws_iam_role_policy" "example" {
  name   = "example"
  role   = aws_iam_role.example.name
  policy = jsonencode({
    "Statement" = [{
      # This policy allows software running on the EC2 instance to access the S3 API.
      "Action" = "s3:*",
      "Effect" = "Allow",
    }],
  })
}

resource "aws_instance" "example" {
  ami           = "ami-a1b2c3d4"
  instance_type = "t2.micro"

  # Terraform can infer from this that the instance profile must be created before the EC2 instance.
  iam_instance_profile = aws_iam_instance_profile.example

  /* However, if software running in this EC2 instance needs access to the S3 API in order to boot properly, there is also a "hidden" dependency on the
aws_iam_role_policy that Terraform cannot automatically infer, so it must be declared explicitly */
  depends_on = [ aws_iam_role_policy.example ]
}


90. SET and LIST data type
-----------------------------
Same as Python with [] - not ordered version 
list = ["a","b","c"] - order is important






















































