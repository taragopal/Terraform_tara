76. Terraform Output 
-------------------
terraform has the Output vaiable {}

* You can run the terraform plan again to see the old output 
* can inspect the tf.state file and see the output blocks 
Run: terraform output <output-valuable> 

This would pull updates from the output which could be an input for a script for a new file.

77. Specific versions to run the code 
----------------------------------------
Can be added to terraform{} 
-- Backend Configuration
-- Experimental features
-- Required Provider and versions 
-- Required Terraform version 
-- Pass meta data 

Terraform blocks are used for code blocks that runs on specific versions. 
Declates the latest versions of the TF plugins. 

terraform{
required_version = "1.08" 

required_providers {
  aws = {
      version = 5.7
      source = "harshicorp/aws"
  }
}
}

When we run "terraform plan" would fail, as its expecting the exact version of the terraform. Adding required_providers block can be used to declare the provider 
details and the versions. 

78. Resource TARGETTING in Terraform
-----------------------------------------
Allow the changes to a specific subset of resources rather than applying changes to the entire infrastructure. 
Use the -target ðŸš©  "<resource-name>  with terraform apply / plan command. 

terraform plan -target <>
terraform destroy -target <>
terraform init -target <>

79. DEALING with large infrastructure, when the state file is in sync
------------------------------------------------------------------------
API throttling: When we exceed the quota of number of allowed API calls. 
Single terraform plan create an enormous amount of API calls. It could impact the performance of the production instances. 

--refresh the resources while running plan 
--convert a big project to a smaller project. ec2, iam, vpc, subnet, storage, load balancers, nfs, port, policies, vnet, security group, 
-- Disable the refesh flag ðŸš©: refresh = false 


80. ZIPMAP function: 
zipmap (keylist, valuelist) 

>zipmap (["a", "b"], [1, 2]) 
{
"a" =1,
"b" =2,
}

Note: This can be used to assign values to IAM users, polcies, ports, IPs or serveral other assignment types of operations. 

81. Adding comments
:
# Single line comments 
// alternative to #
/* muti line comments */

82. Meta arguments and resource behaviour : 
Allows to customize the resouces, which comes inside the resource blocks. 

example: 
ignore_changes= [tags] 
depends_on = 
count = 
for_each = 
lifecycle {
  create_before_destroy 
  prevent_destroy (bool)
  ignore_changes (list of attribute names) 
  replace_triggered_by (list of resource or attribute references)
  }
provider = 

* You can add precondition and postcondition blocks 

83 - Lifecycle meta arguments
84 - Create_before_destroy 
  : adding conditions for a resouce dependency, ex, installing the right patches before installing apache etc etc. This prevents the downtime. 
85 - prevent_destroy 
  : safety against accidental deletes. This does not prevent the remote objects from being destroyed if the resource block is entirely removed from the config file. 
86 - Ignore_changes
  : terraform apply auto-approve 
resource "aws_instance" "example" {
  # ...

  lifecycle {
    ignore_changes = [
      # Ignore changes to tags, e.g. because a management agent
      # updates these based on some ruleset managed elsewhere.
      tags, <details>
    ]
  }
}




























































